system aebs;
type int = range 0 .. 255;
// Camera
const cameraOffset = 0;
const cameraPeriodic = 15;
const cameraPeriodicJitter = 1;
const cameraDelay = 2;
const cameraDelayJitter = 1;
// Lidar
const lidarOffset = 0;
const lidarPeriodic = 15;
const lidarPeriodicJitter = 1;
const lidarDelay = 2;
const lidarDelayJitter = 1;
// Radar
const radarOffset = 0;
const radarPeriodic = 15;
const radarPeriodicJitter = 1;
const radarDelay = 2;
const radarDelayJitter = 1;
// Fusion
const fusionOffset = 0;
const fusionPeriodic = 10;
const fusionPeriodicJitter = 1;
const fusionExecution = 2;
const fusionExecutionJitter = 1;
// Controller
const controllerExecution = 3;
const controllerExecutionJitter = 1;
// Alarm
const alarmProcessing = 2;
const alarmProcessingJitter = 1;
// Brake
const brakeOffset = 0;
const brakePeriodic = 10;
const brakePeriodicJitter = 1;
const brakeProcessing = 2;
const brakeProcessingJitter = 1;
// Signals
signal cameraData();
signal lidarData();
signal radarData();
signal fusionData();
signal controllerData();
// Camera process
process Camera(1);
    var x clock;
    var e clock;
    state startS #start ;
        set x := 0;
        nextstate first;
    endstate;
    state first;
        when x = cameraOffset;
            informal "Camera_START";
            set x := 0;
            set e := 0;
            nextstate exec1;
    endstate;
    state exec1;
        deadline delayable;
        when e >= (cameraDelay - cameraDelayJitter) and e <= (cameraDelay + cameraDelayJitter);
            informal "Camera_FINISH";
            output cameraData() to {Fusion}0;
            reset e;
            nextstate wait1;
    endstate;
    state wait1;
        when x = (cameraPeriodic - cameraPeriodicJitter);
            set x := 0;
            nextstate jitter;
    endstate;
    state jitter;
        deadline delayable;
        when x <= (cameraPeriodicJitter * 2);
            informal "Camera_START";
            set e := 0;
            nextstate exec2;
    endstate;
    state exec2;
        deadline delayable;
        when e >= (cameraDelay - cameraDelayJitter) and e <= (cameraDelay + cameraDelayJitter);
            informal "Camera_FINISH";
            output cameraData() to {Fusion}0;
            reset e;
            nextstate wait2;
    endstate;
    state wait2;
        when x = cameraPeriodic;
            set x := 0;
            nextstate jitter;
    endstate;
endprocess;
// Lidar process
process Lidar(1);
    var x clock;
    var e clock;
    state startS #start ;
        set x := 0;
        nextstate first;
    endstate;
    state first;
        when x = lidarOffset;
            informal "Lidar_START";
            set x := 0;
            set e := 0;
            nextstate exec1;
    endstate;
    state exec1;
        deadline delayable;
        when e >= (lidarDelay - lidarDelayJitter) and e <= (lidarDelay + lidarDelayJitter);
            informal "Lidar_FINISH";
            output lidarData() to {Fusion}0;
            reset e;
            nextstate wait1;
    endstate;
    state wait1;
        when x = (lidarPeriodic - lidarPeriodicJitter);
            set x := 0;
            nextstate jitter;
    endstate;
    state jitter;
        deadline delayable;
        when x <= (lidarPeriodicJitter * 2);
            informal "Lidar_START";
            set e := 0;
            nextstate exec2;
    endstate;
    state exec2;
        deadline delayable;
        when e >= (lidarDelay - lidarDelayJitter) and e <= (lidarDelay + lidarDelayJitter);
            informal "Lidar_FINISH";
            output lidarData() to {Fusion}0;
            reset e;
            nextstate wait2;
    endstate;
    state wait2;
        when x = lidarPeriodic;
            set x := 0;
            nextstate jitter;
    endstate;
endprocess;
// Radar process
process Radar(1);
    var x clock;
    var e clock;
    state startS #start ;
        set x := 0;
        nextstate first;
    endstate;
    state first;
        when x = radarOffset;
            informal "Radar_START";
            set x := 0;
            set e := 0;
            nextstate exec1;
    endstate;
    state exec1;
        deadline delayable;
        when e >= (radarDelay - radarDelayJitter) and e <= (radarDelay + radarDelayJitter);
            informal "Radar_FINISH";
            output radarData() to {Fusion}0;
            reset e;
            nextstate wait1;
    endstate;
    state wait1;
        when x = (radarPeriodic - radarPeriodicJitter);
            set x := 0;
            nextstate jitter;
    endstate;
    state jitter;
        deadline delayable;
        when x <= (radarPeriodicJitter * 2);
            informal "Radar_START";
            set e := 0;
            nextstate exec2;
    endstate;
    state exec2;
        deadline delayable;
        when e >= (radarDelay - radarDelayJitter) and e <= (radarDelay + radarDelayJitter);
            informal "Radar_FINISH";
            output radarData() to {Fusion}0;
            reset e;
            nextstate wait2;
    endstate;
    state wait2;
        when x = radarPeriodic;
            set x := 0;
            nextstate jitter;
    endstate;
endprocess;
// Fusion process
process Fusion(1);
    var x clock;
    var e clock;
    var data int;
    state startA #start ;
        task data := 0;
        set x := 0;
        nextstate first;
    endstate;
    state first;
        when x = fusionOffset;
            set x := 0;
            set e := 0;
            nextstate preprocessing1;
        input cameraData();
            task data := data + 1;
            nextstate first;
        input lidarData();
            task data := data + 1;
            nextstate first;
        input radarData();
            task data := data + 1;
            nextstate first;
    endstate;
    state preprocessing1;
        deadline eager;
        provided data = 0;
            informal "Fusion_USELESS_PROCESS";
            nextstate processing1a;
        deadline eager;
        provided data <> 0;
            informal "Fusion_USEFUL_PROCESS";
            task data := 0;
            nextstate processing1b;
    endstate;
    state processing1a;
        deadline delayable;
        when e >= (fusionExecution - fusionExecutionJitter) and e <= (fusionExecution + fusionExecutionJitter);
            informal "Fusion_FINISH";
            reset e;
            nextstate wait1;
        input cameraData();
            task data := data + 1;
            nextstate processing1a;
        input lidarData();
            task data := data + 1;
            nextstate processing1a;
        input radarData();
            task data := data + 1;
            nextstate processing1a;
    endstate;
    state processing1b;
        deadline delayable;
        when e >= (fusionExecution - fusionExecutionJitter) and e <= (fusionExecution + fusionExecutionJitter);
            informal "Fusion_FINISH";
            output fusionData() to {Controller}0;
            reset e;
            nextstate wait1;
        input cameraData();
            task data := data + 1;
            nextstate processing1b;
        input lidarData();
            task data := data + 1;
            nextstate processing1b;
        input radarData();
            task data := data + 1;
            nextstate processing1b;
    endstate;
    state wait1;
        when x = (fusionPeriodic - fusionPeriodicJitter);
            set x := 0;
            nextstate jitter;
        input cameraData();
            task data := data + 1;
            nextstate wait1;
        input lidarData();
            task data := data + 1;
            nextstate wait1;
        input radarData();
            task data := data + 1;
            nextstate wait1;
    endstate;
    state jitter;
        deadline delayable;
        when x <= (fusionPeriodicJitter * 2);
            set e := 0;
            nextstate preprocessing2;
        input cameraData();
            task data := data + 1;
            nextstate jitter;
        input lidarData();
            task data := data + 1;
            nextstate jitter;
        input radarData();
            task data := data + 1;
            nextstate jitter;
    endstate;
    state preprocessing2;
        deadline eager;
        provided data = 0;
            informal "Fusion_USELESS_PROCESS";
            nextstate processing2a;
        deadline eager;
        provided data <> 0;
            informal "Fusion_USEFUL_PROCESS";
            task data := 0;
            nextstate processing2b;
    endstate;
    state processing2a;
        deadline delayable;
        when e >= (fusionExecution - fusionExecutionJitter) and e <= (fusionExecution + fusionExecutionJitter);
            informal "Fusion_FINISH";
            reset e;
            nextstate wait2;
        input cameraData();
            task data := data + 1;
            nextstate processing2a;
        input lidarData();
            task data := data + 1;
            nextstate processing2a;
        input radarData();
            task data := data + 1;
            nextstate processing2a;
    endstate;
    state processing2b;
        deadline delayable;
        when e >= (fusionExecution - fusionExecutionJitter) and e <= (fusionExecution + fusionExecutionJitter);
            informal "Fusion_FINISH";
            output fusionData() to {Controller}0;
            reset e;
            nextstate wait2;
        input cameraData();
            task data := data + 1;
            nextstate processing2b;
        input lidarData();
            task data := data + 1;
            nextstate processing2b;
        input radarData();
            task data := data + 1;
            nextstate processing2b;
    endstate;
    state wait2;
        when x = fusionPeriodic;
            set x := 0;
            nextstate jitter;
        input cameraData();
            task data := data + 1;
            nextstate wait2;
        input lidarData();
            task data := data + 1;
            nextstate wait2;
        input radarData();
            task data := data + 1;
            nextstate wait2;
    endstate;
endprocess;
// Controller process
process Controller(1);
    var e clock;
    state wait #start ;
        input fusionData();
            informal "Controller_START";
            set e := 0;
            nextstate processing;
    endstate;
    state processing;
        deadline delayable;
        when e >= (controllerExecution - controllerExecutionJitter) and e <= (controllerExecution + controllerExecutionJitter);
            informal "Controller_FINISH";
            output controllerData() to {Alarm}0;
            output controllerData() to {Brake}0;
            reset e;
            nextstate wait;
    endstate;
endprocess;
// Alarm process
process Alarm(1);
    var e clock;
    state wait #start ;
        input controllerData();
            informal "Alarm_START";
            set e := 0;
            nextstate processing;
    endstate;
    state processing;
        deadline delayable;
        when e >= (alarmProcessing - alarmProcessingJitter) and e <= (alarmProcessing + alarmProcessingJitter);
            informal "Alarm_FINISH";
            reset e;
            nextstate wait;
    endstate;
endprocess;
// Brake process
process Brake(1);
    var x clock;
    var e clock;
    var nbData int;
    state startA #start ;
        task nbData := 0;
        set x := 0;
        nextstate first;
    endstate;
    state first;
        when x = brakeOffset;
            set x := 0;
            set e := 0;
            nextstate preprocessing1;
        input controllerData();
            task nbData := nbData + 1;
            nextstate first;
    endstate;
    state preprocessing1;
        deadline eager;
        provided nbData =  0;
            informal "Brake_USELESS_ACTUATION";
            nextstate processing1;
        deadline eager;
        provided nbData <>  0;
            informal "Brake_USEFUL_ACTUATION";
            task nbData := 0;
            nextstate processing1;
    endstate;
    state processing1;
        deadline delayable;
        when e >= (brakeProcessing - brakeProcessingJitter) and e <= (brakeProcessing + brakeProcessingJitter);
            informal "Brake_FINISH";
            reset e;
            nextstate wait1;
        input controllerData();
            task nbData := nbData + 1;
            nextstate processing1;
    endstate;
    state wait1;
        when x = (brakePeriodic - brakePeriodicJitter);
            set x := 0;
            nextstate jitter;
        input controllerData();
            task nbData := nbData + 1;
            nextstate wait1;
    endstate;
    state jitter;
        deadline delayable;
        when x <= (brakePeriodicJitter * 2);
            set e := 0;
            nextstate preprocessing2;
        input controllerData();
            task nbData := nbData + 1;
            nextstate jitter;
    endstate;
    state preprocessing2;
        deadline eager;
        provided nbData =  0;
            informal "Brake_USELESS_ACTUATION";
            nextstate processing2;
        deadline eager;
        provided nbData <>  0;
            informal "Brake_USEFUL_ACTUATION";
            task nbData := 0;
            nextstate processing2;
    endstate;
    state processing2;
        deadline delayable;
        when e >= (brakeProcessing - brakeProcessingJitter) and e <= (brakeProcessing + brakeProcessingJitter);
            informal "Brake_FINISH";
            reset e;
            nextstate wait2;
        input controllerData();
            task nbData := nbData + 1;
            nextstate processing2;
    endstate;
    state wait2;
        when x = brakePeriodic;
            set x := 0;
            nextstate jitter;
        input controllerData();
            task nbData := nbData + 1;
            nextstate wait2;
    endstate;
endprocess;
endsystem;