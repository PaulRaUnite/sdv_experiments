system simple;
type int = range 0 .. 255;

// Sensor
const sensorOffset = 0;
const sensorPeriodic = 15;
const sensorPeriodicJitter = 1;
const sensorDelay = 2;
const sensorDelayJitter = 1;
// Controller
const controllerExecution = 3;
const controllerExecutionJitter = 1;
// Actuator
const actuatorOffset = 0;
const actuatorPeriodic = 5;
const actuatorPeriodicJitter = 1;
const actuatorProcess = 2;
const actuatorProcessJitter = 1;
// Signals
signal sensorData();
signal controllerData();

// Sensor process
process Sensor(1);
    var x clock;
    var e clock;
    state startS #start ;
        set x := 0;
        nextstate first;
    endstate;
    state first;
        when x = sensorOffset;
            informal "S_START";
            set x := 0;
            set e := 0;
            nextstate exec1;
    endstate;
    state exec1;
        deadline delayable;
        when e >= (sensorDelay - sensorDelayJitter) and e <= (sensorDelay + sensorDelayJitter);
            informal "S_FINISH";
            output sensorData() to {Controller}0;
            reset e;
            nextstate wait1;
    endstate;
    state wait1;
        when x = (sensorPeriodic - sensorPeriodicJitter);
            set x := 0;
            nextstate jitter;
    endstate;
    state jitter;
        deadline delayable;
        when x <= (sensorPeriodicJitter * 2);
            informal "S_START";
            set e := 0;
            nextstate exec2;
    endstate;
    state exec2;
        deadline delayable;
        when e >= (sensorDelay - sensorDelayJitter) and e <= (sensorDelay + sensorDelayJitter);
            informal "S_FINISH";
            output sensorData() to {Controller}0;
            reset e;
            nextstate wait2;
    endstate;
    state wait2;
        when x = sensorPeriodic;
            set x := 0;
            nextstate jitter;
    endstate;
endprocess;

// Controller process
process Controller(1);
    var e clock;
    state wait #start ;
        input sensorData();
            informal "C_START";
            set e := 0;
            nextstate processing;
    endstate;
    state processing;
        deadline delayable;
        when e >= (controllerExecution - controllerExecutionJitter) and e <= (controllerExecution + controllerExecutionJitter);
            informal "C_FINISH";
            output controllerData() to {Actuator}0;
            reset e;
            nextstate wait;
    endstate;
endprocess;

// Actuator process
process Actuator(1);
    var x clock;
    var e clock;
    var data int;
    state startA #start ;
        task data := 0;
        set x := 0;
        nextstate first;
    endstate;
    state first;
        when x = actuatorOffset;
            set x := 0;
            set e := 0;
            nextstate preprocessing1;
        input controllerData();
            task data := data + 1;
            nextstate first;
    endstate;
    state preprocessing1;
        deadline eager;
        provided data =  0;
            informal "USELESS_ACT";
            nextstate processing1;
        deadline eager;
        provided data <>  0;
            informal "USEFUL_ACT";
            task data := 0;
            nextstate processing1;
    endstate;
    state processing1;
        deadline delayable;
        when e >= (actuatorProcess - actuatorProcessJitter) and e <= (actuatorProcess + actuatorProcessJitter);
            informal "A_FINISH";
            reset e;
            nextstate wait1;
        input controllerData();
            task data := data + 1;
            nextstate processing1;
    endstate;
    state wait1;
        when x = (actuatorPeriodic - actuatorPeriodicJitter);
            set x := 0;
            nextstate jitter;
        input controllerData();
            task data := data + 1;
            nextstate wait1;
    endstate;
    state jitter;
        deadline delayable;
        when x <= (actuatorPeriodicJitter * 2);
            set e := 0;
            nextstate preprocessing2;
        input controllerData();
            task data := data + 1;
            nextstate jitter;
    endstate;
    state preprocessing2;
        deadline eager;
        provided data =  0;
            informal "USELESS_ACT";
            nextstate processing2;
        deadline eager;
        provided data <>  0;
            informal "USEFUL_ACT";
            task data := 0;
            nextstate processing2;
    endstate;
    state processing2;
        deadline delayable;
        when e >= (actuatorProcess - actuatorProcessJitter) and e <= (actuatorProcess + actuatorProcessJitter);
            informal "A_FINISH";
            reset e;
            nextstate wait2;
        input controllerData();
            task data := data + 1;
            nextstate processing2;
    endstate;
    state wait2;
        when x = actuatorPeriodic;
            set x := 0;
            nextstate jitter;
        input controllerData();
            task data := data + 1;
            nextstate wait2;
    endstate;
endprocess;
endsystem;